package readme

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"
)

func writeTempFile(t *testing.T, content string) string {
	f, err := os.CreateTemp("", "readme-test-*.yaml")
	if err != nil {
		t.Fatal(err)
	}
	if _, err := f.Write([]byte(content)); err != nil {
		t.Fatal(err)
	}
	if err := f.Close(); err != nil {
		t.Fatal(err)
	}
	return f.Name()
}

func renderTableFromValues(t *testing.T, valuesYaml string) string {
	path := writeTempFile(t, valuesYaml)
	defer os.Remove(path)
	vals, err := createValuesObject(path)
	if err != nil {
		t.Fatal(err)
	}
	meta, err := parseMetadataComments(path)
	if err != nil {
		t.Fatal(err)
	}
	combine(vals)
	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}
	rendered := buildParamsToRender(params)
	return markdownTable(rendered)
}

func TestObjectWithNestedFields(t *testing.T) {
	yamlContent := `
## @typedef {struct} Backup - Backup configuration
## @field {bool} enabled - Enable regular backups
## @field {string} schedule - Cron schedule for automated backups

## @param {Backup} backup - Backup configuration
backup:
  enabled: false
  schedule: "0 2 * * *"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`backup`") || !strings.Contains(table, "`{}`") {
		t.Errorf("expected backup object with `{}`, got:\n%s", table)
	}
	if !strings.Contains(table, "`backup.enabled`") || !strings.Contains(table, "`false`") {
		t.Errorf("expected nested field with value false:\n%s", table)
	}
	if !strings.Contains(table, "`backup.schedule`") || !strings.Contains(table, "`0 2 * * *`") {
		t.Errorf("expected nested field with cron value:\n%s", table)
	}
}

func TestArrayWithValues(t *testing.T) {
	yamlContent := `
## @typedef {struct} MetricsStorage - Metrics storage configuration
## @field {string} name="5d" - Name
## @field {string} retentionPeriod - Retention

## @param {[]MetricsStorage} metricsStorages - Metrics storage
metricsStorages:
- name: shortterm
  retentionPeriod: "3d"
- name: longterm
  retentionPeriod: "14d"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`metricsStorages`") || !strings.Contains(table, "`[...]`") {
		t.Errorf("expected root array with `[...]`, got:\n%s", table)
	}
	if !strings.Contains(table, "`[]object`") {
		t.Errorf("expected type to be `[]object`, got:\n%s", table)
	}
	if !strings.Contains(table, "`metricsStorages[i].name`") || !strings.Contains(table, "`\"\"`") {
		t.Errorf("expected element name shortterm with [i], got:\n%s", table)
	}
	if !strings.Contains(table, "`metricsStorages[i].retentionPeriod`") || !strings.Contains(table, "`5d`") {
		t.Errorf("expected element retention 5d with [i], got:\n%s", table)
	}
}

func TestEmptyArrayWithZeroValues(t *testing.T) {
	yamlContent := `
## @typedef {struct} LogsStorage - Logs storage configuration
## @field {string} name - Name
## @field {string} retentionPeriod - Retention

## @param {[]LogsStorage} logsStorages - Logs storage
logsStorages: []
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`logsStorages`") || !strings.Contains(table, "`[]`") {
		t.Errorf("expected logsStorages root array with `[]`, got:\n%s", table)
	}
	if !strings.Contains(table, "`logsStorages[i].name`") || !strings.Contains(table, "`\"\"`") {
		t.Errorf("expected placeholder element with empty string, got:\n%s", table)
	}
}

func TestMapWithNestedObjects(t *testing.T) {
	yamlContent := `
## @typedef {struct} DatabaseRoles - Database roles
## @field {[]string} admin - Admin users

## @typedef {struct} Database - Database configuration
## @field {*DatabaseRoles} roles - Roles

## @param {map[string]Database} databases - Databases
databases:
  myapp:
    roles:
      admin: ["user1","user2"]
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`databases`") || !strings.Contains(table, "`{...}`") {
		t.Errorf("expected databases map with `{...}`, got:\n%s", table)
	}
	if !strings.Contains(table, "`map[string]object`") {
		t.Errorf("expected type to be `map[string]object`, got:\n%s", table)
	}
	if !strings.Contains(table, "`databases[name].roles.admin`") || !strings.Contains(table, "`[]`") {
		t.Errorf("expected nested roles.admin array without users, got:\n%s", table)
	}
}

func TestEmptyMapWithNestedObjects(t *testing.T) {
	yamlContent := `
## @typedef {struct} User - User configuration
## @field {string} [password] - Password for the user (autogenerated if not provided)

## @param {map[string]User} users - Users configuration map
users: {}
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`users`") || !strings.Contains(table, "`{}`") {
		t.Errorf("expected users empty map with `{}`, got:\n%s", table)
	}
	if !strings.Contains(table, "`map[string]object`") {
		t.Errorf("expected type to be `map[string]object`, got:\n%s", table)
	}
	// Even though User has fields, empty map should show {} not {...}
	if strings.Contains(table, "`users`.*`{...}`") {
		t.Errorf("expected empty map to render as `{}` not `{...}`, got:\n%s", table)
	}
}

func TestNestedObjectDefaults(t *testing.T) {
	yamlContent := `
## @typedef {struct} PostgresqlParameters - PostgreSQL parameters
## @field {int} max_connections - Max connections

## @typedef {struct} Postgresql - PostgreSQL configuration
## @field {PostgresqlParameters} parameters - Parameters

## @param {Postgresql} postgresql - PostgreSQL
postgresql: {}
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`postgresql.parameters.max_connections`") || !strings.Contains(table, "`0`") {
		t.Errorf("expected zero-value for int field, got:\n%s", table)
	}
}

func TestNormalizeQuantityTypes(t *testing.T) {
	require.Equal(t, "quantity", normalizeType("quantity"))
	require.Equal(t, "*quantity", normalizeType("*quantity"))
}

func TestStringEnumStripped(t *testing.T) {
	if normalizeType("string enum:\"nano,micro\"") != "string" {
		t.Errorf("expected enum type to be stripped to string")
	}
}

func TestEmptyStringsRenderedAsQuoted(t *testing.T) {
	if valueString("", true, "string") != "`\"\"`" {
		t.Errorf("expected empty string to be rendered as `\"\"`")
	}
}

func TestIntegerLists(t *testing.T) {
	yamlContent := `
## @param {[]int} intList - A required list of integers, empty.
intList:

## @param {[]int} intListSingle - A list of integers with one value.
intListSingle:
  - 80

## @param {[]int} intListMultiple - A list of integers with one value.
intListMultiple:
  - 80
  - 8080

## @param {[]*int} intListNullable - A nullable list of integers, empty.
intListNullable:

## @param {[]*int} intListNullableSingle - A nullable list of integers with one value.
intListNullableSingle:
  - 80

## @param {[]*int} intListNullableMultiple - A nullable list of integers with multiple values.
intListNullableMultiple:
  - 80
  - 8080
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`intList`") || !strings.Contains(table, "`[]`") {
		t.Errorf("expected empty intList as [] got:\n%s", table)
	}
	if !strings.Contains(table, "`intListSingle`") || !strings.Contains(table, "`[80]`") {
		t.Errorf("expected intListSingle with 80 got:\n%s", table)
	}
	if !strings.Contains(table, "`intListMultiple`") || !strings.Contains(table, "`[80, 8080]`") {
		t.Errorf("expected intListMultiple with 2 values got:\n%s", table)
	}
	if !strings.Contains(table, "`intListNullableMultiple`") || !strings.Contains(table, "`[80, 8080]`") {
		t.Errorf("expected intListNullableMultiple with 2 values got:\n%s", table)
	}
}

func TestStringLists(t *testing.T) {
	yamlContent := `
## @param {[]string} stringList - A required list of strings, empty.
stringList:

## @param {[]string} stringListSingle - A required list of strings with one value.
stringListSingle:
  - "user1"

## @param {[]string} stringListMultiple - A required list of strings with multiple values.
stringListMultiple:
  - "user1"
  - "user2"

## @param {[]*string} stringListNullable - A nullable list of strings, empty.
stringListNullable:

## @param {[]*string} stringListNullableSingle - A nullable list of strings with one value.
stringListNullableSingle:
  - "user1"

## @param {[]*string} stringListNullableMultiple - A nullable list of strings with multiple values.
stringListNullableMultiple:
  - "user1"
  - "user2"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`stringListMultiple`") || !strings.Contains(table, "`[user1, user2]`") {
		t.Errorf("expected stringListMultiple with 2 values got:\n%s", table)
	}
	if !strings.Contains(table, "`stringListNullableSingle`") || !strings.Contains(table, "`[user1]`") {
		t.Errorf("expected stringListNullableSingle with 1 value got:\n%s", table)
	}
}

func TestBasicTypes(t *testing.T) {
	yamlContent := `
## @param {int} testInt - Integer variable
testInt:
## @param {int} testIntDefault - Integer variable with default value
testIntDefault: 10
## @param {bool} testBoolTrue - Boolean variable, defaults to true
testBoolTrue: true
## @param {string} testStringDefault - String variable with default value
testStringDefault: "hello"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`testInt`") || !strings.Contains(table, "`0`") {
		t.Errorf("expected testInt as 0 got:\n%s", table)
	}
	if !strings.Contains(table, "`testIntDefault`") || !strings.Contains(table, "`10`") {
		t.Errorf("expected testIntDefault as 10 got:\n%s", table)
	}
	if !strings.Contains(table, "`testBoolTrue`") || !strings.Contains(table, "`true`") {
		t.Errorf("expected testBoolTrue as true got:\n%s", table)
	}
	if !strings.Contains(table, "`testStringDefault`") || !strings.Contains(table, "`hello`") {
		t.Errorf("expected testStringDefault as hello got:\n%s", table)
	}
}

func TestQuantities(t *testing.T) {
	yamlContent := `
## @param {quantity} quantityDefaultCpuShare - A quantity default with vCPU share.
quantityDefaultCpuShare: "100m"
## @param {*quantity} quantityNullableDefaultRam - A nullable quantity with a default RAM size.
quantityNullableDefaultRam: "500MiB"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`quantityDefaultCpuShare`") || !strings.Contains(table, "`100m`") {
		t.Errorf("expected quantityDefaultCpuShare as 100m got:\n%s", table)
	}
	if !strings.Contains(table, "`quantityNullableDefaultRam`") || !strings.Contains(table, "`500MiB`") {
		t.Errorf("expected quantityNullableDefaultRam as 500MiB got:\n%s", table)
	}
}

func TestComplexObjectFields(t *testing.T) {
	yamlContent := `
## @typedef {struct} FooDB - FooDB configuration
## @field {string} volume - Sub-field declared with path relative to custom type

## @typedef {struct} Foo - Foo configuration
## @field {FooDB} db - Field with custom type declared locally

## @param {Foo} foo - Configuration for foo
foo:
  db:
    volume: "10Gi"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`foo.db.volume`") || !strings.Contains(table, "`10Gi`") {
		t.Errorf("expected foo.db.volume as 10Gi got:\n%s", table)
	}
}

func TestTemplateVar(t *testing.T) {
	yamlContent := `
## @typedef {struct} Test - Test type

## @param {Test} test - Test variable
test:
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`test`") || !strings.Contains(table, "`{}`") {
		t.Errorf("expected test as {} got:\n%s", table)
	}
}

func TestNullableDefaultsRenderedAsNull(t *testing.T) {
	yamlContent := `
## @param {*int} testIntNullable - Integer variable, nullable
testIntNullable:

## @param {*bool} testBoolNullable - Boolean variable, nullable
testBoolNullable:

## @param {*string} testStringNullable - String variable, nullable
testStringNullable:

## @param {*quantity} quantityNullable - A nullable quantity value.
quantityNullable:

## @param {*[]int} intListNullable - A nullable list of integers, empty.
intListNullable:

## @param {*[]string} stringListNullable - A nullable list of strings, empty.
stringListNullable:
`
	table := renderTableFromValues(t, yamlContent)
	expected := []string{
		"`testIntNullable`", "`null`",
		"`testBoolNullable`", "`null`",
		"`testStringNullable`", "`null`",
		"`quantityNullable`", "`null`",
		"`intListNullable`", "`null`",
		"`stringListNullable`", "`null`",
	}
	for i := 0; i < len(expected); i += 2 {
		if !strings.Contains(table, expected[i]) || !strings.Contains(table, expected[i+1]) {
			t.Errorf("expected %s to be rendered as %s, got:\n%s", expected[i], expected[i+1], table)
		}
	}
}

func TestValidationUnknownField(t *testing.T) {
	yamlContent := `
## @typedef {struct} FooDB - FooDB configuration
## @field {string} size - Size

## @typedef {struct} Foo - Foo configuration
## @field {FooDB} db - Database

## @param {Foo} foo - Foo object
foo:
  db:
    sie: 10Gi
`
	path := writeTempFile(t, yamlContent)
	defer os.Remove(path)
	vals, _ := createValuesObject(path)
	meta, _ := parseMetadataComments(path)
	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}
	err := validateValues(params, typeFields, vals, meta.KnownTypes)
	if err == nil || !strings.Contains(err.Error(), "foo.db.sie") {
		t.Errorf("expected error about unknown field foo.db.sie, got: %v", err)
	}
}

func TestNestedFieldAnnotations(t *testing.T) {
	yamlContent := `
## @section Alerta configuration

## @typedef {struct} TelegramAlerts - Telegram alerts configuration
## @field {string} token - Telegram token for your bot
## @field {string} chatID - Specify multiple ID's separated by comma
## @field {string} disabledSeverity - List of severity without alerts

## @typedef {struct} Alerts - Alerts configuration
## @field {TelegramAlerts} telegram - Configuration for Telegram alerts

## @typedef {struct} AlertaResources - Alerta resources configuration
## @field {*Resources} limits - Resources limits for alerta
## @field {*Resources} requests - Resources requests for alerta

## @typedef {struct} Alerta - Alerta configuration
## @field {string} storage - Persistent Volume size for alerta database
## @field {string} storageClassName - StorageClass used to store the data
## @field {*AlertaResources} resources - Resources configuration for alerta
## @field {Alerts} alerts - Configuration for alerts

## @param {Alerta} alerta - Configuration for Alerta
alerta:
  storage: 10Gi
  storageClassName: ""
  resources:
    limits:
      cpu: "1"
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 256Mi
  alerts:
    telegram:
      token: "abc"
      chatID: "123"
      disabledSeverity: "warn"
`
	table := renderTableFromValues(t, yamlContent)
	if !strings.Contains(table, "`alerta.alerts.telegram.token`") || !strings.Contains(table, "`abc`") {
		t.Errorf("expected nested telegram token field with abc got:\n%s", table)
	}
	if !strings.Contains(table, "`alerta.alerts.telegram.chatID`") || !strings.Contains(table, "`123`") {
		t.Errorf("expected nested telegram chatID field with 123 got:\n%s", table)
	}
	if !strings.Contains(table, "`alerta.alerts.telegram.disabledSeverity`") || !strings.Contains(table, "`warn`") {
		t.Errorf("expected nested telegram disabledSeverity field with warn got:\n%s", table)
	}
}

func TestNormalizeTypePrimitives(t *testing.T) {
	cases := map[string]string{
		"string":             "string",
		"quantity":           "quantity",
		"duration":           "duration",
		"time":               "time",
		"object":             "object",
		"*quantity":          "*quantity",
		"[]quantity":         "[]quantity",
		"map[string]time":    "map[string]time",
		"map[string]Unknown": "map[string]object", // non-primitive fallback
	}

	for in, want := range cases {
		if got := normalizeType(in); got != want {
			t.Fatalf("normalizeType(%q) = %q, want %q", in, got, want)
		}
	}
}

func TestParamWithoutDescription(t *testing.T) {
	yaml := `
## @param {string} foo
foo: ""
`
	path := writeTempFile(t, yaml)
	defer os.Remove(path)

	meta, err := parseMetadataComments(path)
	require.NoError(t, err)
	require.Len(t, meta.Sections, 1)
	require.Equal(t, "foo", meta.Sections[0].Parameters[0].Name)
	require.Equal(t, "", meta.Sections[0].Parameters[0].Description)
}

func TestAliasObjectDisplaysEmptyBraces(t *testing.T) {
	yaml := `
## @typedef {struct} Asdaa - Asdaa type
## @field {int64} foaa - some field

## @param {Asdaa} foaao
foaao:
  aaa: 1
`
	table := renderTableFromValues(t, yaml)
	require.Contains(t, table, "`foaao`")
	require.Contains(t, table, "`{}`", "alias object should render {} not raw JSON")
}

func TestPointerObjectDefaultsToNull(t *testing.T) {
	yaml := `
## @typedef {struct} Storage - Storage configuration
## @field {string} name - name
## @field {*Resources} resources - nested ptr object

## @param {[]Storage} storages - list
storages:
- name: s1
`
	table := renderTableFromValues(t, yaml)
	require.Contains(t, table, "`storages[i].resources`")
	require.Contains(t, table, "`null`", "missing pointer-to-object should render `null`")
}

func TestMapStringObjectDefaultsRenderAndValidate(t *testing.T) {
	yamlContent := `
## @section Application-specific parameters

## @typedef {struct} Gpu - GPU configuration
## @field {string} name - Name of GPU

## @typedef {struct} Resources - Resources configuration
## @field {*quantity} cpu - Available CPU
## @field {*quantity} memory - Available memory (RAM)

## @typedef {struct} Node - Node configuration
## @field {int} minReplicas - Minimum amount of replicas
## @field {int} maxReplicas - Maximum amount of replicas
## @field {string} instanceType - Virtual machine instance type
## @field {quantity} ephemeralStorage - Ephemeral storage size
## @field {[]string} roles - List of node's roles
## @field {Resources} resources - Available resources for each worker node
## @field {[]Gpu} gpus - List of GPUs to attach

## @param {map[string]Node} nodeGroups - Worker nodes configuration
nodeGroups:
  md0:
    minReplicas: 0
    maxReplicas: 10
    instanceType: "u1.medium"
    ephemeralStorage: 20Gi
    roles:
      - ingress-nginx
    resources:
      cpu: ""
      memory: ""
    gpus: []
`

	// validate does not error on map[string]T defaults
	path := writeTempFile(t, yamlContent)
	defer os.Remove(path)

	vals, err := createValuesObject(path)
	require.NoError(t, err)

	meta, err := parseMetadataComments(path)
	require.NoError(t, err)

	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}

	require.NoError(t, validateValues(params, typeFields, vals, meta.KnownTypes))

	// README table renders `{...}` for map[string]object
	table := renderTableFromValues(t, yamlContent)
	require.Contains(t, table, "`nodeGroups`")
	require.Contains(t, table, "`{...}`")
	require.Contains(t, table, "`map[string]object`")
}

func TestUnknownComplexTypesAreRejected(t *testing.T) {
	yamlContent := `
## @typedef {struct} Config - Config configuration
## @field {*Merge} merge - Additional config
## @field {Resolver} resolver - Additional resolver config

## @param {Config} config - NATS configuration
config:
  merge: {}
  resolver: {}
`
	path := writeTempFile(t, yamlContent)
	defer os.Remove(path)

	vals, err := createValuesObject(path)
	require.NoError(t, err)

	meta, err := parseMetadataComments(path)
	require.NoError(t, err)

	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}

	err = validateValues(params, typeFields, vals, meta.KnownTypes)
	require.Error(t, err)
	require.Contains(t, err.Error(), "type 'Merge' referenced at 'config.merge' has no schema")
}

func TestObjectAliasAllowsFreeForm(t *testing.T) {
	yamlContent := `
## @typedef {struct} Config - Config configuration
## @field {object} merge - Additional config
## @field {object} resolver - Additional resolver config

## @param {Config} config - NATS configuration
config:
  merge: {}
  resolver: {}
`
	path := writeTempFile(t, yamlContent)
	defer os.Remove(path)

	vals, err := createValuesObject(path)
	require.NoError(t, err)

	meta, err := parseMetadataComments(path)
	require.NoError(t, err)

	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}

	require.NoError(t, validateValues(params, typeFields, vals, meta.KnownTypes))
}

func TestSourceUploadSchemaFromTopBlock(t *testing.T) {
	yamlContent := `
## @section Common parameters

## @typedef {struct} UploadImage - Upload image configuration
## @field {string} name - Name of the image to use

## @typedef {struct} Emptyobject - Empty object
	
## @typedef {struct} UploadHTTP - Upload HTTP configuration
## @field {string} url - URL to download the image

## @typedef {struct} Source - Source configuration
## @field {*UploadImage} image - Use image by name
## @field {*Emptyobject} upload - Upload local image
## @field {*UploadHTTP} http - Download image from an HTTP source

## @param {Source} source - The source image location used to create a disk
source: {}

## @param {bool} optical - Defines if disk should be considered optical
optical: false

## @param {quantity} storage - The size of the disk allocated for the virtual machine
## @param {string} storageClass - StorageClass used to store the data
storage: 5Gi
storageClass: replicated
`
	path := writeTempFile(t, yamlContent)
	defer os.Remove(path)

	vals, err := createValuesObject(path)
	require.NoError(t, err)

	meta, err := parseMetadataComments(path)
	require.NoError(t, err)

	var params []ParamMeta
	for _, s := range meta.Sections {
		params = append(params, s.Parameters...)
	}

	// validate should pass: 'source' type schema is known
	require.NoError(t, validateValues(params, typeFields, vals, meta.KnownTypes))

	// rendered table should show object for emptyobject and nested fields
	table := renderTableFromValues(t, yamlContent)
	require.Contains(t, table, "`source`")
	require.Contains(t, table, "`{}`")
	require.Contains(t, table, "`source.image`")
	require.Contains(t, table, "`source.upload`") // emptyobject displayed as object
	require.Contains(t, table, "`source.http`")
	// normalizeType for emptyobject
	require.NotContains(t, table, "`emptyobject`")
	require.Contains(t, table, "`object`")
}

func TestNoDuplicateFields(t *testing.T) {
	yamlContent := `
## @section Example

## @typedef {struct} Resources - Resources configuration
## @field {*quantity} cpu - CPU
## @field {*quantity} memory - Memory

## @typedef {struct} Storage - Storage configuration
## @field {*Resources} requests - Requests
## @field {*Resources} limits - Limits

## @param {Storage} storage - Storage root
storage:
  requests:
    cpu: "200m"
    memory: "256Mi"
`

	table := renderTableFromValues(t, yamlContent)

	if strings.Count(table, "`storage.requests`") != 1 {
		t.Fatalf("expected exactly one row for storage.requests, got:\n%s", table)
	}
	if strings.Count(table, "`storage.limits`") != 1 {
		t.Fatalf("expected exactly one row for storage.limits, got:\n%s", table)
	}
	if strings.Count(table, "`storage.requests.cpu`") != 1 {
		t.Fatalf("expected exactly one row for storage.requests.cpu, got:\n%s", table)
	}
	if strings.Count(table, "`storage.requests.memory`") != 1 {
		t.Fatalf("expected exactly one row for storage.requests.memory, got:\n%s", table)
	}
}

func TestPointerToSliceOfObjectsRenderedAndTraversed(t *testing.T) {
	yaml := `
## @typedef {struct} Gpu - GPU configuration
## @field {string} name - Name

## @typedef {struct} Node - Node configuration
## @field {*[]Gpu} gpus - GPUs (optional)

## @param {Node} node - Node configuration
node:
  gpus: []
`
	table := renderTableFromValues(t, yaml)

	require.Contains(t, table, "`node.gpus`", "pointer-to-slice param missing")
	require.Contains(t, table, "`[]object`", "type for *slice should render as []object")
	require.Contains(t, table, "`[]`", "value for empty *[] should render as [] (not null) when provided empty list")

	require.Contains(t, table, "`node.gpus[i].name`", "element field not traversed")
	require.Contains(t, table, "`\"\"`", "element field default for string should be empty quoted")
}

func TestPointerObjectAlwaysNullEvenWhenProvided(t *testing.T) {
	yaml := `
## @section Example

## @typedef {struct} Request - Request configuration
## @field {*quantity} cpu
## @field {*quantity} memory

## @typedef {struct} Limit - Limit configuration
## @field {*quantity} cpu
## @field {*quantity} memory

## @typedef {struct} Resources - Resources configuration
## @field {*Request} requests
## @field {*Limit} limits

## @typedef {struct} Alerta - Alerta configuration
## @field {*Resources} resources - Resources configuration

## @param {Alerta} alerta - Alerta
alerta:
  resources:
    requests:
      cpu: 100m
      memory: 256Mi
    limits:
      cpu: "1"
      memory: 1Gi
`
	table := renderTableFromValues(t, yaml)

	// All pointer-to-object values must be `null` in README regardless of presence
	require.Contains(t, table, "`alerta.resources`")
	require.Regexp(t, "`alerta\\.resources`.*\\|\\s*`\\*object`\\s*\\|\\s*`null`", table)

	require.Contains(t, table, "`alerta.resources.requests`")
	require.Regexp(t, "`alerta\\.resources\\.requests`.*\\|\\s*`\\*object`\\s*\\|\\s*`null`", table)

	require.Contains(t, table, "`alerta.resources.limits`")
	require.Regexp(t, "`alerta\\.resources\\.limits`.*\\|\\s*`\\*object`\\s*\\|\\s*`null`", table)
}

func TestExplicitDefaultAnnotationRawObject(t *testing.T) {
	yamlContent := `
## @typedef {struct} NodeGroup - Node group configuration
## @field {int} minReplicas=0 - Minimum amount of replicas
## @field {int} maxReplicas=10 - Maximum amount of replicas
## @field {string} instanceType="u1.medium" - Virtual machine instance type
## @field {quantity} ephemeralStorage="20Gi" - Ephemeral storage size
## @field {[]string} roles=[] - List of node's roles
## @field {Resources} resources={} - Resources available to each worker node
## @field {[]Gpu} gpus={"name":"nvidia.com/AD102GL_L40S"} - GPUs

## @param {map[string]NodeGroup} nodeGroups - Worker nodes configuration
nodeGroups: {}
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`nodeGroups[name].instanceType`")
	require.Contains(t, table, "`u1.medium`")

	require.Contains(t, table, "`nodeGroups[name].ephemeralStorage`")
	require.Contains(t, table, "`20Gi`")

	require.Contains(t, table, "`nodeGroups[name].roles`")
	require.Contains(t, table, "`[]`")

	require.Contains(t, table, "`nodeGroups[name].resources`")
	require.Contains(t, table, "`{}`")

	require.Contains(t, table, "`nodeGroups[name].gpus[i].name`")
	require.Contains(t, table, "`nvidia.com/AD102GL_L40S`")
}

func TestExplicitDefaultEmptyObject(t *testing.T) {
	yamlContent := `
## @typedef {struct} Backup - Backup configuration
## @field {object} settings={} - Freeform settings

## @param {Backup} backup - Backup configuration
backup: {}
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`backup.settings`")
	require.Contains(t, table, "`{}`", "expected explicit default={} to render as {}")
}

func TestEnumTypesDisplayAsBaseType(t *testing.T) {
	yamlContent := `
## @enum {string} ResourcesPreset - Default sizing preset
## @value nano
## @value micro
## @value small
## @value medium
## @value large
## @value xlarge
## @value 2xlarge

## @param {ResourcesPreset} resourcesPreset - Default sizing preset used when resources is omitted
resourcesPreset: "small"
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`resourcesPreset`", "param should be present")
	require.Contains(t, table, "`string`", "enum type should display as base type 'string' not 'object'")
	require.Contains(t, table, "`small`", "enum default value should be extracted from values.yaml")
	require.NotContains(t, table, "`object`", "enum should not be displayed as object")
	require.NotContains(t, table, "`{}`", "enum should not have {} as default")
}

func TestEnumFieldInStructDisplaysCorrectly(t *testing.T) {
	yamlContent := `
## @enum {string} ResourcesPreset - Default sizing preset
## @value nano
## @value micro
## @value small

## @typedef {struct} ClickHouseKeeper - ClickHouse Keeper configuration
## @field {bool} [enabled] - Deploy ClickHouse Keeper for cluster coordination
## @field {quantity} [size] - Persistent Volume Claim size
## @field {ResourcesPreset} [resourcesPreset] - Default sizing preset
## @field {int} [replicas] - Number of Keeper replicas

## @param {ClickHouseKeeper} clickhouseKeeper - ClickHouse Keeper configuration
clickhouseKeeper:
  enabled: true
  size: 1Gi
  resourcesPreset: micro
  replicas: 3
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`clickhouseKeeper.resourcesPreset`", "enum field should be present")
	require.Contains(t, table, "`string`", "enum field type should display as 'string' not 'object'")
	require.Contains(t, table, "`micro`", "enum field default value should be 'micro' not '{}'")
	require.NotContains(t, table, "`clickhouseKeeper.resourcesPreset`.*`object`", "enum field should not be object")
}

func TestMultipleEnumFieldsWithDifferentDefaults(t *testing.T) {
	yamlContent := `
## @enum {string} ResourcesPreset - Sizing preset
## @value nano
## @value micro
## @value small
## @value medium

## @typedef {struct} Resources - Explicit CPU and memory configuration
## @field {quantity} [cpu] - CPU available
## @field {quantity} [memory] - Memory (RAM) available

## @param {int} replicas - Number of replicas
replicas: 2

## @param {Resources} [resources] - Explicit CPU and memory configuration
resources: {}

## @param {ResourcesPreset} resourcesPreset - Default sizing preset
resourcesPreset: "small"

## @typedef {struct} Keeper - Keeper configuration
## @field {ResourcesPreset} [resourcesPreset] - Default sizing preset

## @param {Keeper} keeper - Keeper configuration
keeper:
  resourcesPreset: nano
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`resourcesPreset`", "root enum param should be present")
	require.Regexp(t, "`resourcesPreset`.*\\|.*`string`.*\\|.*`small`", table, "root enum should show type string and value small")

	require.Contains(t, table, "`keeper.resourcesPreset`", "nested enum field should be present")
	require.Regexp(t, "`keeper\\.resourcesPreset`.*\\|.*`string`.*\\|.*`nano`", table, "nested enum should show type string and value nano")

	require.NotContains(t, table, "`object`.*`{}`", "enums should not display as object with {}")
}

func TestPointerToEnumDisplaysCorrectly(t *testing.T) {
	yamlContent := `
## @enum {string} Topology - Seaweedfs topology
## @value single
## @value multi

## @param {*Topology} topology - Optional topology configuration
topology:
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`topology`", "pointer-to-enum param should be present")
	require.Contains(t, table, "`*string`", "pointer-to-enum should display as *string not *object")
	require.Contains(t, table, "`null`", "pointer-to-enum without value should be null")
	require.NotContains(t, table, "`*object`", "pointer-to-enum should not be *object")
}

func TestArrayOfEnumsDisplaysCorrectly(t *testing.T) {
	yamlContent := `
## @enum {string} PresetSize - Size preset
## @value small
## @value medium
## @value large

## @param {[]PresetSize} presets - List of presets
presets:
  - small
  - large
`
	table := renderTableFromValues(t, yamlContent)

	require.Contains(t, table, "`presets`", "array-of-enums param should be present")
	require.Contains(t, table, "`[]string`", "array-of-enums should display as []string not []object")
	require.Contains(t, table, "`[small, large]`", "array-of-enums should show actual values")
	require.NotContains(t, table, "`[]object`", "array-of-enums should not be []object")
}
